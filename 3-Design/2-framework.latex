\section{Framework}

The framework, on which the simulations were built and forms the core of MACE,
was itself built on the multi-agent simulation system Presage
\footnote{\url{https://sites.google.com/site/presageproject},
\url{http://sammacbeth.github.com/Presage/}}.
Presage is a `time' driven system:
the simulations are divided into discrete cycles, in which each participant
processes any queued inputs, and responds with any appropriate actions.
The environment, which represents the world that
the participants are acting in, processes these actions and, if applicable, sends
inputs to participants informing them of changes that might have taken place.
The messaging framework is designed to be primarily asynchronous, with the
information not being processed until the following cycle, but allows for
synchronous messaging via clever use of code.

The purpose of the framework was to allow a number of agents to play the
grouping and stag games.
To this end, it was implemented as an abstraction and
a security layer, simultaneously defining a simple interface between agent code
and the environment and simulation layers, whilst also not allowing the agents to
cheat. Three major classes were implemented:
\begin{itemize}
\item{
The Evironment, which models the world and holds all relevant data,
such as the animals which exist and the status of agents.
}
\item{
The AbstractAgent, which models the hunters themselves and wraps around both the hunter's
data model and the set of actions that they may perform (and when they may perform them).
}
\item{
The AbstractGroup, which models a group (or tribe) of agents, wrapping around the backing
model and the actions the groups can perform.
}
\end{itemize}

\begin{figure}[p]
  \caption{TODO: Write some words about this}
  \label{framework-flow}
  \pgraphic{framework}
\end{figure}

The actual simulation uses Agents and Groups that are derived from the
AbstractAgent and AbstractGroup, which are treated as hostile code - in the
future, these classes may be written by parties that wish to break the rues of
the system, so the interactions have to a mediated and controlled by the
Abstract implementations.
This was achieved by implementing many members as
private (including all data members), and any non-private members were declared
as `final', thus stopping derived classes from altering their functionality.
The remainder of the code was formed as a number of protected abstract methods,
which need to be implemented by the revived agent or group that are used for
all interactions.

Due to the overall complexity of the three games when combined, and the default
asynchronous nature of the underlying framework, we opted to have each round
of the games being execute over a number of cycles, each with a well defined
purpose, defined in the TurnType enumerator.
Every cycle, the three primary
framework classes check what turn it currently is, and evecute the relevant
methods; these will include calling the appropriate abstract methods (that will
have been implemented by the derived code).
The flow is shown in figure \ref{framework-flow} (page \pageref{framework-flow}).

\subsection{Alterations to Underlying Code}

Due to the current builds of Presage being in beta, a number of changes were
made to the supplied code. Nearly all of these were purely cosmetic improvements
and alterations; updating the code to fit the guidelines of the current production
version of the Java standard library, such as the use of generic types for
lists and iterators.
Another of these changes, which was key for later validation
of the code, was the replacement of the `temporary' debugging code with a
thread safe logging system, based off the standard libraries Logger class.

Presage's execution loop was also altered in order to make it safe for dynamic
introduction of participants, such as emergent groups, by iterating over the
set of Participants manually, and marking each that had been executed (See
snippet \ref{ParticipantLoop}, page \pageref{ParticipantLoop}).
This uses the same strict ordering as the original code, using the 
fundamental String Comparator, and, therefore, guarantees the same 
deterministic order of execution when no participants are added during execution.

The result when a new participant is added is a deterministic function of the
it's identifier: it will be executed in the correct point in the
sequence if it's `greater than' than the participant that caused it to be created,
or it will be dealt with last if it was `less than'.
Regardless, it is still guaranteed to be executed in the current cycle.

\subsection{Security Model}

Due to a combination of Java's security management, and Presage's liberal
permissions model, security was implemented in a number of different ways
in different parts of the framework, which is outlined in figure
\ref{uml_security}.

There were three levels of security, which were roughly levelled as shown in
the diagram.
The Simulation security level corrospondes primarily to the data which is
required by, and distributed by, Presage itself.
This level, therefore, includes all of Presage's core simulation classes
except those direcly related to Participants, which Presage already treats
as partial-trust code.

The next level is the framework, which actually only contains about half
of the classes of the framework.
Most of the classes in the framework security are not accessible directly
by the simulation framwork, but are rather mapped through the public layer.
Equally, the simualtion classes are not directly available here;
the primary point of contact `upstream' is the EnivronmentConnection,
which is passed downwards at initialisation time.

The third, public, layer both forms the glue that allows for full interaction
and contains all of the untrusted code implementation code.

\begin{figure}[h]
  \label{uml_security}
  \pgraphic{uml_security}
  \caption{
    The framework was split into three security levels, determining which
	classes shoudl be able to get references to which other classes.
	This diagram shows which classes belong to which level, and some of the
	important interactions between them.
  }
\end{figure}

The Enivronment was protected by the Environment Connections, a concept
that already existed in Presage, meaning that only the Simulation, Plugins
and the Environment itself could get a reference to the Environment of the
current simulation.
Although plugins are not considered trusted code, and can also interact with
agent's implementation code, this protection was considered sufficient;
this decision relates to the fact that the Plugin interface requires a
reference to the Simulation object at initialisation time.
The EnvironmentConnection class itself, however, is not public-safe - it 
does offer a couple of functions that should not be directly exposed to the
agent implementation - such as the function `seekAdvice' which, if called
directly, would allow agents to side step the requirement to consume resources
in exchange for seeking advice.
This problem is addressed with the PublicEnvironmentConnection.

A Similar theory was applied the Participants. The Interface requirement that
a reference to the Participant's PlayerDataModel was publically accessible
presented a major problem, as this would mean that participants have the same level
of access to other's data model as their own.
However, this was eventually used to our advantage by returning only a wrapped
version of the DataModel, which was the only reference avialable to both external
entities (including Plugins, the Enivornment, and other Participants) which, although
breaking the formal contract of the system, permitted us to correctly implement the
security system.

Permissions here were slightly looser than would have been liked, as both the
Enivronment and plugins can access the Participant object and - using only the
lightest parts of the reflection libraries - transform these into references to
either AbstractAgents or AbstractGroupAgents.

\subsection{Environment}

\begin{figure}[p]
  \label{uml_env}
  \caption{
    The four primary classes, and the action handlers, that make up the Environment
	package.
	Member methods have been roughly by the class of object they are used to interact
	with.
	The class interactions can be seen in figure \ref{uml_security}.
  }
  \pgraphic{uml_environment}
\end{figure}

The environment implementation is primarily a nexus for agent communications and
some housekeeping in corner cases.
The main functionality of the data model, for exmaple, it to keep track of all the
active objects - be it Agents, Groups, Foods - a task that is already done by the
Simulation class.
The repelciation here, however, is for time effiency:
as the Simulation does not know to differentiate between agents and groups, each
look up would take longer\footnote{
  Especially for returning the lists, where reutrning a strong unmodifiable reference
  to the internal list is a single operation, but deriviing it is $\mathcal{O}(n)$
  in the number of Participants in the system.
}.

The data model also inherites the knowledge of the current cycle number and
this is augmented with the current TurnType, which indiciated the position in
the current round.
This is updated in the overidden setTime method, along with additional code to
ensure that on the first cycle, that the first TurnType is selected.

This is determined, as are the turn orders, by use of the strcit natural
ordering of enumberated types in java:
the order of a set of values is strictly always the order in which they are
declared.
Thus, the order of turns is always the order in which the instance variables
are declared in the TurnTypes enumerated class.

The primary component of the Enivronment as a physical world is the information
about food:
the set of all food stuffs in existence, and their properties as contained within
the Food objects, is immutable and set on creation of the simulation.
This is also true of the less physcial set of all classes of Groups that are
permitted.

Individual groups are not created with the simulation but, instead, by agents who
wish to start a community.
As the framework interface for all classes of group are the same, being defined
in AbstractGroupAgent, the limitation that the simulation environment places on
group formation is the classes of group that are permitted in the environment.
This functionality also allows that an agent does not need to understand the full
nature of the group that it creates: the class objects that it can query mean
that no strong references to a particular implementation are required.
There were plans for agents to be able to get metadata about particular class
types, but this was not implemented due to a lack of demand; very few classes
of group were implemented in this course of the project.

Food, on the other hand, works in almost the opposite way. Food objects are
created as an a priori part of the Environment, and initialised with their
parameters.
These are currently limited to the food's name (for debugging and display
purposes), the amound of nutrition the food has in total, and the number
of hunters required to hunt it.
Each of thsoe hunters will receive their portion - the total nutrition divided
by the number of hunters - if and only if at least the required number of
hunters in the team chose to hunt that type of food.
Entensions to food were planning to look at food distributions in terms of
both nutrition, and the number of a type of food that are available to hunt.

\subsection{Agents}

\begin{figure}[p]
  \label{uml_agent}
  \caption{
    Diagram to show the AbstractAgent implementation and contract, along with
	the private and public data models.
	Also shown as the input handlers.
	Class interaction diagram can be seen in figure \ref{uml_security}
  }
  \pgraphic{uml_agent}
\end{figure}

\subsection{Groups}

\subsubsection{Free Agent Groups}

TODO: Discuss the meanings of different turns \\
TODO: Mentions the free agent group \\
TODO: Describe why some things are synchronous \\
TODO: Possibly discuss how the encapsulation works \\
TODO: Make reference to the repeatability parameters

